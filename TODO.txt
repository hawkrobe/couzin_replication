TODO:

* Decide what to do with stopping mechanism
  - if keep going past destination marker, need to start new round standing still
  - if press button to stop, need to change destination mechanism
  - if stop at destination, need to expand boundary condition
* Make rounds last longer

* The new design will have the highest scoring region appearing in some location that depends on the human player’s current position. In the “close” conditions, after a random interval, say between 5 and 10 seconds, the highest scoring region should appear at the player’s location (or the closest valid point for the it, which may be different in the wall condition).  Also, it should disappear at random after a random interval between 5 and 10 seconds, and then reappear again. (previously, "randomize location of centroid via transformation")

* I think beyond increasing the width of the wall, we should also make the center area have 0 points in the wall condition, and we should invert the player booting so that if the player is inactive in the center region for too long, we remove them, as we did when they were against the wall in the original implementation.

* I wanted to add instruction pages in between the rounds 1 and 2, and rounds 2 and 3.  I’m not sure how to do that in the current architecture, but maybe now it is best to implement then in the javascript given we abandoned the URL-passing-data architecture.  I was thinking these instructions would be quite simple, e.g. ("You will now play 1 round where the score field is visible. Click here to begin.”… “You will now play one round where the score field is invisible”… “You will now play 4 rounds with other players.”)

* To make the game a little more engaging, I was thinking maybe we should make the space bar just give a little temporary boost to speed, and then you have to wait some random number of milliseconds before you can boost again. What do you think?

* It might be worth considering still doing the 1-bit communication flag. I was thinking about what might be a reasonable way to implement this given the current control.  One way I was thinking was holding down the mouse button and shaking the mouse around, as if you are waving a flag. What do you think?

COMPLETED:

* Convert to 1 player game (expert)
* Read in other player positions
* Read in new csv of just scorefield centroid
  -- set to 1 in 20 pixel radius of that centroid, .5 elsewhere, 0 at edges
* Click to move instead of arrow keys
* Allow more than 2 people to be in a room together
  -- Don't need separate function for 'host' and 'other', since players are identical
  -- Notify and update clients when new player joins
* Set sizes & speeds to couzin spec
* Integrate keyboard.js to collect user input
* remove all the clicking functions
* get turning to work smoothly (constant angular velocity)
* get space bar boost to work
* display modifications
  -- big curr bonus header
  -- smaller cumulative bonus & time remaining trackers
  -- color curr bonus val with gradient
  -- move instructions to footer (clear out playable space)
* draw visibility radius around each player
  -- actually block view of other players outside of visibility radius (during round)
* start game once threshold number of players has been reached 
* collect next set of players in waiting room once first game starts
* reset positions to center beginning of each round
* allow people to disconnect gracefully (without ending the game)
* keep track of how long the game has been going
-> give player correct feedback about how many minutes are remaining
* put dots on circle to represent direction
* integrate light field
-> give player correct feedback about current & cumulative bonus 
* write the data we want to file
-> curr bonus, positions, keyboard inputs, active?, angle, noise level, velocity, list of players in visibility radius
* change color of whole background (not viewpoint -- white to green)
* redirect to landing page after 6 min. (http://people.csail.mit.edu/pkrafft/experiment/landing.html)
* set bonus at 0 around edge
* get UID from querystring
* read num. players and noise level from file when creating a game
